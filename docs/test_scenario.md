# 고수준 통합 도구 테스트 시나리오

이 문서는 새로 구현된 고수준 통합 도구들의 테스트 시나리오를 정의합니다.

## 테스트 환경 준비

### 필수 요구사항
- Windows 10/11 환경
- Tesseract OCR 설치 및 PATH 설정 완료
- MCP 서버가 Cursor에 등록되어 있음
- 테스트용 애플리케이션 준비:
  - 메모장 (Notepad)
  - 계산기 (Calculator)
  - 웹 브라우저 (Chrome/Edge)

### 테스트 전 확인사항
1. MCP 서버가 정상적으로 실행 중인지 확인
2. 화면 인덱싱 DB가 초기화되어 있는지 확인 (선택적)
3. 테스트용 윈도우들이 열려 있는지 확인

---

## 1. click_text 도구 테스트

### 시나리오 1.1: 기본 텍스트 클릭 (전체 화면)

**목적**: 화면에서 텍스트를 찾아 클릭하는 기본 기능 테스트

**전제 조건**:
- 화면에 "저장" 버튼이 보이는 애플리케이션이 열려 있음

**테스트 단계**:
1. Cursor AI 채팅에서 다음 명령 실행:
   ```
   "저장 버튼을 클릭해줘"
   ```

2. 또는 직접 도구 호출:
   ```json
   {
     "name": "click_text",
     "arguments": {
       "search_text": "저장",
       "exact_match": false,
       "button": "left"
     }
   }
   ```

**예상 결과**:
- 인덱싱이 자동으로 수행됨 (최신 상태가 아닌 경우)
- "저장" 텍스트를 찾아서 해당 위치를 클릭
- 성공 메시지와 클릭한 위치 정보 반환

**검증 포인트**:
- ✅ 인덱싱이 자동으로 수행되는가?
- ✅ 텍스트를 정확히 찾는가?
- ✅ 올바른 위치를 클릭하는가?
- ✅ 응답 시간이 합리적인가? (5초 이내)

---

### 시나리오 1.2: 특정 윈도우에서 텍스트 클릭

**목적**: 특정 윈도우 내에서만 텍스트를 검색하여 클릭하는 기능 테스트

**전제 조건**:
- 메모장이 열려 있고, 메뉴바에 "파일" 메뉴가 보임

**테스트 단계**:
1. 먼저 윈도우 찾기:
   ```json
   {
     "name": "window_find",
     "arguments": {
       "title": "메모장"
     }
   }
   ```

2. 찾은 hwnd를 사용하여 클릭:
   ```json
   {
     "name": "click_text",
     "arguments": {
       "search_text": "파일",
       "window_id": <hwnd>,
       "exact_match": false
     }
   }
   ```

**예상 결과**:
- 메모장 윈도우만 인덱싱됨
- 메모장 내에서 "파일" 텍스트를 찾아 클릭
- 파일 메뉴가 열림

**검증 포인트**:
- ✅ 윈도우별 인덱싱이 제대로 작동하는가?
- ✅ 다른 윈도우의 텍스트를 찾지 않는가?
- ✅ 윈도우 내에서 정확한 위치를 클릭하는가?

---

### 시나리오 1.3: 텍스트를 찾을 수 없는 경우

**목적**: 존재하지 않는 텍스트에 대한 에러 처리 테스트

**테스트 단계**:
```json
{
  "name": "click_text",
  "arguments": {
    "search_text": "존재하지않는텍스트12345",
    "exact_match": false
  }
}
```

**예상 결과**:
- 인덱싱은 수행됨
- 텍스트를 찾을 수 없다는 에러 메시지 반환
- `success: false` 및 적절한 에러 메시지

**검증 포인트**:
- ✅ 명확한 에러 메시지가 반환되는가?
- ✅ 시스템이 크래시하지 않는가?
- ✅ 부분 일치도 시도했는지 확인 메시지가 있는가?

---

### 시나리오 1.4: 정확히 일치하는 텍스트 검색

**목적**: exact_match 옵션 테스트

**전제 조건**:
- 화면에 "저장"과 "저장하기" 텍스트가 모두 존재

**테스트 단계**:
```json
{
  "name": "click_text",
  "arguments": {
    "search_text": "저장",
    "exact_match": true
  }
}
```

**예상 결과**:
- 정확히 "저장"만 매칭됨
- "저장하기"는 매칭되지 않음

**검증 포인트**:
- ✅ exact_match가 제대로 작동하는가?
- ✅ 부분 일치 텍스트가 제외되는가?

---

## 2. type_text 도구 테스트

### 시나리오 2.1: 기본 텍스트 입력

**목적**: 입력 필드를 찾아 텍스트를 입력하는 기본 기능 테스트

**전제 조건**:
- 메모장이 열려 있고 활성화되어 있음

**테스트 단계**:
```json
{
  "name": "type_text",
  "arguments": {
    "search_text": "메모장",
    "text": "안녕하세요, 테스트입니다."
  }
}
```

**예상 결과**:
- 메모장 영역을 찾아 클릭
- 텍스트가 입력됨
- 성공 메시지 반환

**검증 포인트**:
- ✅ 입력 필드를 정확히 찾는가?
- ✅ 클릭 후 텍스트가 입력되는가?
- ✅ 텍스트가 올바르게 입력되는가?

---

### 시나리오 2.2: 검색 필드에 입력

**목적**: 검색창 같은 특정 필드에 입력하는 테스트

**전제 조건**:
- 웹 브라우저가 열려 있고 주소창이 보임

**테스트 단계**:
```json
{
  "name": "type_text",
  "arguments": {
    "search_text": "주소",
    "text": "https://www.google.com"
  }
}
```

**예상 결과**:
- 주소창을 찾아 클릭
- URL이 입력됨

**검증 포인트**:
- ✅ 올바른 입력 필드를 찾는가?
- ✅ 긴 텍스트도 정상 입력되는가?

---

### 시나리오 2.3: 입력 필드를 찾을 수 없는 경우

**목적**: 입력 필드 검색 실패 시 에러 처리 테스트

**테스트 단계**:
```json
{
  "name": "type_text",
  "arguments": {
    "search_text": "존재하지않는필드",
    "text": "테스트"
  }
}
```

**예상 결과**:
- 명확한 에러 메시지 반환
- `success: false`

**검증 포인트**:
- ✅ 적절한 에러 메시지가 반환되는가?

---

## 3. find_element 도구 테스트

### 시나리오 3.1: 기본 요소 찾기

**목적**: 화면에서 요소를 찾아 위치 정보를 반환하는 기능 테스트

**테스트 단계**:
```json
{
  "name": "find_element",
  "arguments": {
    "search_text": "로그인",
    "exact_match": false
  }
}
```

**예상 결과**:
- 요소를 찾은 경우: 위치 정보 (x, y, center_x, center_y) 반환
- 찾지 못한 경우: `found: false` 반환

**검증 포인트**:
- ✅ 정확한 위치 정보가 반환되는가?
- ✅ 여러 개의 매칭이 있으면 모두 반환되는가?
- ✅ 찾지 못한 경우 적절한 메시지가 반환되는가?

---

### 시나리오 3.2: 여러 요소 찾기

**목적**: 동일한 텍스트가 여러 곳에 있는 경우 테스트

**전제 조건**:
- 화면에 "확인" 버튼이 여러 개 있음

**테스트 단계**:
```json
{
  "name": "find_element",
  "arguments": {
    "search_text": "확인",
    "exact_match": false
  }
}
```

**예상 결과**:
- 모든 "확인" 요소의 위치 정보가 반환됨
- `count` 필드에 개수 표시

**검증 포인트**:
- ✅ 모든 매칭이 반환되는가?
- ✅ 개수가 정확한가?

---

## 4. interact_window 도구 테스트

### 시나리오 4.1: 기본 윈도우 상호작용

**목적**: 윈도우에서 여러 작업을 순차적으로 수행하는 기능 테스트

**전제 조건**:
- 메모장이 열려 있음

**테스트 단계**:
```json
{
  "name": "interact_window",
  "arguments": {
    "window_title": "메모장",
    "actions": [
      {
        "type": "click_text",
        "search_text": "파일"
      },
      {
        "type": "type",
        "text": "안녕하세요"
      }
    ]
  }
}
```

**예상 결과**:
- 메모장을 찾아 활성화
- 파일 메뉴 클릭
- 텍스트 입력
- 모든 작업이 성공적으로 완료됨

**검증 포인트**:
- ✅ 윈도우를 정확히 찾는가?
- ✅ 윈도우가 활성화되는가?
- ✅ 작업들이 순차적으로 수행되는가?
- ✅ 각 작업의 결과가 반환되는가?

---

### 시나리오 4.2: 복합 작업 수행

**목적**: 다양한 작업 유형을 조합한 테스트

**전제 조건**:
- 메모장이 열려 있음

**테스트 단계**:
```json
{
  "name": "interact_window",
  "arguments": {
    "window_title": "메모장",
    "actions": [
      {
        "type": "type",
        "text": "Hello World"
      },
      {
        "type": "hotkey",
        "keys": ["ctrl", "a"]
      },
      {
        "type": "hotkey",
        "keys": ["ctrl", "c"]
      },
      {
        "type": "key",
        "key": "end"
      },
      {
        "type": "hotkey",
        "keys": ["ctrl", "v"]
      }
    ]
  }
}
```

**예상 결과**:
- 텍스트 입력
- 전체 선택
- 복사
- 끝으로 이동
- 붙여넣기
- 모든 작업 성공

**검증 포인트**:
- ✅ 다양한 작업 유형이 모두 작동하는가?
- ✅ 단축키가 정상 작동하는가?
- ✅ 작업 순서가 올바른가?

---

### 시나리오 4.3: 윈도우를 찾을 수 없는 경우

**목적**: 존재하지 않는 윈도우에 대한 에러 처리 테스트

**테스트 단계**:
```json
{
  "name": "interact_window",
  "arguments": {
    "window_title": "존재하지않는윈도우12345",
    "actions": [
      {
        "type": "type",
        "text": "테스트"
      }
    ]
  }
}
```

**예상 결과**:
- 명확한 에러 메시지 반환
- `success: false`

**검증 포인트**:
- ✅ 적절한 에러 메시지가 반환되는가?

---

### 시나리오 4.4: 작업 중 일부 실패

**목적**: 여러 작업 중 일부가 실패하는 경우 테스트

**전제 조건**:
- 메모장이 열려 있음

**테스트 단계**:
```json
{
  "name": "interact_window",
  "arguments": {
    "window_title": "메모장",
    "actions": [
      {
        "type": "type",
        "text": "성공"
      },
      {
        "type": "click_text",
        "search_text": "존재하지않는텍스트"
      },
      {
        "type": "type",
        "text": "계속"
      }
    ]
  }
}
```

**예상 결과**:
- 첫 번째 작업 성공
- 두 번째 작업 실패 (에러 메시지 포함)
- 세 번째 작업 성공
- 전체 결과에 각 작업의 성공/실패 상태가 포함됨

**검증 포인트**:
- ✅ 실패한 작업이 전체를 중단시키지 않는가?
- ✅ 각 작업의 결과가 개별적으로 반환되는가?
- ✅ 부분 실패가 적절히 처리되는가?

---

## 5. 스마트 인덱싱 테스트

### 시나리오 5.1: 인덱싱 캐싱 테스트

**목적**: 인덱싱이 캐시되어 불필요한 재인덱싱을 방지하는지 테스트

**테스트 단계**:
1. 첫 번째 호출:
   ```json
   {
     "name": "click_text",
     "arguments": {
       "search_text": "저장"
     }
   }
   ```

2. 즉시 두 번째 호출 (같은 화면):
   ```json
   {
     "name": "click_text",
     "arguments": {
       "search_text": "취소"
     }
   }
   ```

**예상 결과**:
- 첫 번째 호출: 인덱싱 수행
- 두 번째 호출: 인덱싱 스킵 (이미 최신 상태)

**검증 포인트**:
- ✅ 두 번째 호출 시 재인덱싱이 발생하지 않는가?
- ✅ 응답 시간이 크게 단축되는가?

---

### 시나리오 5.2: 화면 크기 변경 감지

**목적**: 화면 크기가 변경되면 자동으로 재인덱싱하는지 테스트

**테스트 단계**:
1. 첫 번째 호출 (현재 해상도)
2. 화면 해상도 변경 (또는 윈도우 크기 변경)
3. 두 번째 호출

**예상 결과**:
- 화면 크기 변경 감지
- 자동으로 재인덱싱 수행

**검증 포인트**:
- ✅ 화면 크기 변경이 감지되는가?
- ✅ 자동으로 재인덱싱이 수행되는가?

---

### 시나리오 5.3: 인덱싱 만료 테스트

**목적**: 인덱싱이 오래되어 만료되면 재인덱싱하는지 테스트

**전제 조건**:
- 인덱싱 유효 시간: 5분 (300초)

**테스트 단계**:
1. 첫 번째 호출 (인덱싱 수행)
2. 5분 이상 대기 (또는 DB에서 timestamp 수정)
3. 두 번째 호출

**예상 결과**:
- 인덱싱이 만료되었다고 판단
- 자동으로 재인덱싱 수행

**검증 포인트**:
- ✅ 인덱싱 만료가 감지되는가?
- ✅ 자동으로 재인덱싱이 수행되는가?

---

## 6. 통합 테스트 시나리오

### 시나리오 6.1: 실제 사용 사례 - 메모장에 텍스트 입력 및 저장

**목적**: 실제 사용 사례를 통한 전체 워크플로우 테스트

**전제 조건**:
- 메모장이 열려 있음

**테스트 단계**:
1. 메모장 찾기 및 활성화
2. 텍스트 입력
3. 파일 메뉴 열기
4. 저장 클릭 (또는 Ctrl+S)

**예상 결과**:
- 모든 작업이 순차적으로 성공적으로 완료됨
- 파일이 저장됨

**검증 포인트**:
- ✅ 전체 워크플로우가 정상 작동하는가?
- ✅ 사용자 의도를 정확히 이해하고 수행하는가?

---

### 시나리오 6.2: 실제 사용 사례 - 웹 브라우저 검색

**목적**: 웹 브라우저에서 검색하는 시나리오 테스트

**전제 조건**:
- Chrome 또는 Edge가 열려 있음

**테스트 단계**:
1. 브라우저 찾기 및 활성화
2. 주소창에 검색어 입력
3. Enter 키 입력

**예상 결과**:
- 브라우저가 활성화됨
- 검색어가 입력됨
- 검색이 수행됨

**검증 포인트**:
- ✅ 웹 브라우저에서도 정상 작동하는가?
- ✅ 주소창을 정확히 찾는가?

---

## 7. 성능 테스트

### 시나리오 7.1: 응답 시간 측정

**목적**: 각 도구의 응답 시간이 합리적인지 확인

**테스트 단계**:
1. 각 도구 호출 시 시간 측정
2. 평균 응답 시간 계산

**예상 결과**:
- `click_text`: 5초 이내 (인덱싱 포함 시 10초 이내)
- `type_text`: 5초 이내
- `find_element`: 3초 이내
- `interact_window`: 작업 수에 비례

**검증 포인트**:
- ✅ 응답 시간이 사용자 경험에 적합한가?
- ✅ 불필요한 지연이 없는가?

---

### 시나리오 7.2: 동시 호출 테스트

**목적**: 여러 도구를 빠르게 연속 호출 시 안정성 테스트

**테스트 단계**:
1. 짧은 간격으로 여러 도구 호출
2. 각 호출의 성공 여부 확인

**예상 결과**:
- 모든 호출이 정상 처리됨
- 인덱싱 충돌이 발생하지 않음

**검증 포인트**:
- ✅ 동시 호출이 안전하게 처리되는가?
- ✅ 데이터베이스 락 문제가 없는가?

---

## 8. 에러 처리 테스트

### 시나리오 8.1: OCR 실패 시나리오

**목적**: Tesseract OCR이 실패하는 경우 처리 테스트

**전제 조건**:
- Tesseract가 설치되지 않았거나 경로가 잘못됨

**테스트 단계**:
```json
{
  "name": "click_text",
  "arguments": {
    "search_text": "저장"
  }
}
```

**예상 결과**:
- 명확한 에러 메시지 반환
- Tesseract 설치 필요 안내

**검증 포인트**:
- ✅ 적절한 에러 메시지가 반환되는가?
- ✅ 시스템이 크래시하지 않는가?

---

### 시나리오 8.2: 잘못된 인자 테스트

**목적**: 필수 인자가 누락되거나 잘못된 경우 처리 테스트

**테스트 케이스**:
1. `search_text` 누락
2. 잘못된 타입의 인자
3. 범위를 벗어난 값

**예상 결과**:
- 각 케이스에 대해 명확한 에러 메시지 반환

**검증 포인트**:
- ✅ 입력 검증이 제대로 작동하는가?
- ✅ 에러 메시지가 명확한가?

---

## 테스트 결과 기록

각 테스트 시나리오를 실행한 후 다음 정보를 기록하세요:

- **테스트 날짜**: YYYY-MM-DD
- **테스트 환경**: Windows 버전, Python 버전 등
- **결과**: ✅ 성공 / ❌ 실패 / ⚠️ 부분 성공
- **비고**: 문제점, 개선 사항 등

---

## 알려진 제한사항

1. **OCR 정확도**: OCR의 정확도는 화면 해상도, 폰트, 배경색 등에 따라 달라질 수 있습니다.
2. **동적 콘텐츠**: 화면이 자주 변경되는 애플리케이션에서는 인덱싱이 빠르게 만료될 수 있습니다.
3. **다국어 지원**: 현재 한국어와 영어를 기본 지원하지만, 다른 언어는 추가 설정이 필요할 수 있습니다.
4. **윈도우 전용**: 현재 Windows 환경에서만 테스트되었습니다.

---

## 문제 해결 가이드

### 문제: 인덱싱이 너무 느림
- **해결**: `grid_size`를 크게 설정 (기본값: 200)
- **트레이드오프**: 정확도가 낮아질 수 있음

### 문제: 텍스트를 찾을 수 없음
- **해결**: `exact_match`를 `false`로 설정하여 부분 일치 시도
- **해결**: 화면을 다시 인덱싱 (화면이 변경되었을 수 있음)

### 문제: 잘못된 위치 클릭
- **해결**: `grid_size`를 작게 설정하여 더 정밀한 인덱싱
- **해결**: 윈도우별 인덱싱 사용 (`window_id` 지정)

---

**문서 버전**: 1.0  
**작성일**: 2024  
**최종 수정일**: 2024

